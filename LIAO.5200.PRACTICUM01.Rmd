---
title: "Practicum 01"
output:
  html_document:
    df_print: paged
---
AUTHOR: JUSTIN LIAO\

EMAIL: JGLIAO248\@GMAIL.COM

This notebook contains Practicum I that implements a relational database for FAA data set regarding bird strikes onto aircrafts. 

# Setting up R Notebook Environment
## Connect to MySQL database
```{r}
# 1. Library (must be installed prior to loading
library(RMySQL)     ### MySQL

# 2. Settings
db_user <- 'remote'
# use more secured password
db_password <- 'sqlP@$$$'
db_name <- 'BirdStrikeDB'

db_host <- '192.168.1.179' 
db_port <- 3306 # always this port unless you change it during installation

# 3. Connect to DB
dbcon <-  dbConnect(MySQL(), user = db_user, password = db_password,
                 dbname = db_name, host = db_host, port = db_port)

#

# allow for local file edits
command = "set global local_infile=true;"
dbExecute(dbcon, command)




```

## Load data from csv file into r dataframe
```{r}
df = read.csv("BirdStrikesData-V2.csv", stringsAsFactors = FALSE)
```

## Reset Database
```{r}
# need to turn off to delete easily
command = "SET FOREIGN_KEY_CHECKS = 0;"

dbExecute(dbcon, command)

command = "SET GLOBAL log_bin_trust_function_creators = 1;"
dbExecute(dbcon, command)


tables = dbGetQuery(dbcon, "SHOW TABLES")$Tables_in_BirdStrikeDB
if (length(tables) != 0) {
  print("Tables found deleting...")
  for (i in 1:length(tables)) {
    print(paste0("Dropping table: ", tables[i]))
    dbExecute(dbcon, paste0("DROP TABLE IF EXISTS ", tables[i], ";"))
  }
} else {
  print("There were no tables to delete")
}

#turn back on to enforce foreign keys
command = "SET FOREIGN_KEY_CHECKS = 1;"

dbExecute(dbcon, command)

rm(tables)
```


# Part 1: Database Schema Definition


## airports table

The airport table is created with the following format: airports(aid, airportName, airportCode, state). The data indicates that there are sometimes no name for airports because it appears that helicopter pads might not have a name and/or located at an airport. Therefore, there is a chance that the airport is UNKNOWN but the state in which it is located is known. Therefore, the decision was made to clearly identify any possible combination of UNKNOWN airport with a KNOWN state (i.e. UNKNOWN - MA is distinct from UNKNOWN - CT).

### states

Before the airports table is constructed, the states table must be made. The state is a VARCHAR type primary key that holds the state's full name (i.e. MASSACHUSETTS INSTEAD OF MA)

```{r}
command = "DROP TABLE IF EXISTS states;"
dbExecute(dbcon, command)
```

```{r}
command = "
          CREATE TABLE states (
            state VARCHAR(256) PRIMARY KEY
          );
          "
dbExecute(dbcon, command)
```

## Constructing the airports table
airports(aid, airportName, airportCode, state). aid is a synthetic primary key, airportName and state are the airport name and state from the data file. The airport code should be the airport's international code, e.g., BOS for Boston or LGA for LaGuardia. However, you may leave it empty for this database -- it is for future expansion.

The airports table is linked to the states table (look up table). A UNIQUE constraint is used for the airportCode because no two airports should have the same code. Null is allowed for this attribute because some locations might not have an airport code. A UNIQUE constraint is used for the pair values of airportName and state because there should be a distinct difference between two airports. 

```{r}
command = "DROP TABLE IF EXISTS airports;;"
dbExecute(dbcon, command)
```

```{r}
command = "
          CREATE TABLE airports (
            aid INTEGER PRIMARY KEY AUTO_INCREMENT,
            airportName VARCHAR(256) NOT NULL,
            state VARCHAR(256) NOT NULL,
            airportCode VARCHAR(256) UNIQUE,
            
            UNIQUE(airportName, state), 
            FOREIGN KEY (state) REFERENCES states(state)
          );
          "
dbExecute(dbcon, command)
```



## conditions table
Create a lookup table conditions(cid, condition, explanation) and link this lookup table to the incidents table with the conditions foreign key. This table contains the value of all conditions, e.g., 'Overcast'. Leave the explanation column empty (future expansion).

```{r}
command = "DROP TABLE IF EXISTS conditions;"
dbExecute(dbcon, command)
```

Though assignment calls for 'condition' as a column name, 'cond' must be used because 'condition' is a reserved word. Each entry in this table should be unique because a the primary key must be unique per condition and no explanation should be explaining two conditions. 
```{r}


command = "
          CREATE TABLE conditions (
            cid INTEGER PRIMARY KEY AUTO_INCREMENT,
            cond VARCHAR(256) NOT NULL,
            explanation VARCHAR(256),
            UNIQUE(cid, cond, explanation)
          );
          "
dbExecute(dbcon, command)
```


## Harmonize flightphases

### Harmonizing dictionary and data frame. 

A dictionary is created so that when the incidents table is made, a simple reference to this dictionary should convert the raw data to the harmonized data. 
The data frame is craeted to load the table. 
```{r}
unique(df$flight_phase)

# create a dictionary to harmonize dataframe

flight_phase_dict = c()
flight_phase_dict["CLIMB"] <- "INFLIGHT"
flight_phase_dict["LANDING ROLL"] <- "LANDING"
flight_phase_dict["APPROACH"] <- "LANDING"
flight_phase_dict["TAKE-OFF RUN"] <- "TAKEOFF"
flight_phase_dict["DESCENT"] <- "LANDING"
flight_phase_dict["TAXI"] <- "TAKEOFF"
flight_phase_dict["PARKED"] <- "LANDING"
flight_phase_dict[""] <- "UNKNOWN"

unique(flight_phase_dict)

flight_phase_df = data.frame("fpid" = unique(flight_phase_dict))
flight_phase_df


```


```{r}
command = "DROP TABLE IF EXISTS flightPhases;"
dbExecute(dbcon, command)
```

```{r}


command = "
          CREATE TABLE flightPhases (
            fpid VARCHAR(256) PRIMARY KEY
          );
          "
dbExecute(dbcon, command)
```


## 1.G: Remove all flight incidents pertaining to military
This step is completed here so that when data is processed later it won't include any military info.
```{r}
# remove military related data
df = df[which(toupper(df$airline) != "MILITARY"),]

```


## Aircraft Types
There appears to be two different types of aircrafts: airplane and hellicopter. Null values in the original dataset is a hellicopter

### Create aircraft_type_df
This dataframe is used as the primary source of data for the aircraftTypes table in the database. This dataframe will also be used to translate the text to acid PK. 
```{r}
# find unique values
original_aircraft_type = unique(df$aircraft)
# linking empty strings to HELLICOPTER
aircraftType = toupper(c(original_aircraft_type[1], "hellicopter"))

actid = c(1:length(original_aircraft_type))
aircraft_type_key_df = data.frame(actid, aircraftType, original_aircraft_type)

rm(original_aircraft_type, aircraftType, actid)

head(aircraft_type_key_df)

```

### creating aircraftTypes table
```{r}
command = "DROP TABLE IF EXISTS aircraftTypes;"
dbExecute(dbcon, command)
```

```{r}
command = "
          CREATE TABLE aircraftTypes (
            actid INTEGER PRIMARY KEY AUTO_INCREMENT,
            aircraftType VARCHAR(256) UNIQUE NOT NULL
          );
          "
dbExecute(dbcon, command)
```
### Populate aircraftTypes table

```{r}

dbWriteTable(dbcon, 'aircraftTypes', aircraft_type_key_df[,1:2], append = TRUE, row.names = FALSE)
#dbReadTable(dbcon, "aircraftTypes")
```



### aircrafts
There are several model types that were repeated in the csv file. This data was abstracted out to a lookup table with the model names of the aircrafts. 
This table will give each combination of aircraft type and model a unique artificial number. The aircraft type is either airplane or helicopter. 

```{r}
command = "DROP TABLE IF EXISTS aircrafts;"
dbExecute(dbcon, command)
```

```{r}
command = "
          CREATE TABLE aircrafts (
            acid INTEGER PRIMARY KEY AUTO_INCREMENT,
            actid INTEGER NOT NULL,
            model TEXT NOT NULL,
            FOREIGN KEY (actid) REFERENCES aircraftTypes (actid),
            UNIQUE(acid, actid)
          );
          "
dbExecute(dbcon, command)
```

## airlines 

Airlines are stored as a lookup table with the artificial primary key as the the  alid and a unique varchar storing the airline names. 

```{r}
command = "DROP TABLE IF EXISTS airlines;"
dbExecute(dbcon, command)
```

```{r}
command = "
          CREATE TABLE airlines (
            alid INTEGER PRIMARY KEY AUTO_INCREMENT,
            airline VARCHAR(256) UNIQUE NOT NULL
          );
          "
dbExecute(dbcon, command)
```



## incidents table

The incidents table must be made after the definition of the supporting schema because this table references their unique identifiers for several attributes. 

incidents(rid, date, origin, airline, aircraft, flightPhase, altitude, conditions, warning).
For warning, MySQL does not explicitly support booleans. Therefore, tiny int is used where 0 is false and 1 is true. 


```{r}
command = "DROP TABLE IF EXISTS incidents;"
dbExecute(dbcon, command)
```
There are several foreign keys that this table references. The airports, airlines, aircrafts, and conditions are referenced with the respective unique artificial primary key identifiers. The flightphase is a unique varchar. Almost all the attributes are default not null with the exception of flight altitude which is default 0. For airports, airlines, aircrafts, and conditions, if the data is unknown, then it is set to their respective id representing 'UNKNOWN'. Altitude ia allowed to be negative because there are some airports/airfields where the altitude is lower than the reference sea level. 
```{r}
command = "
          CREATE TABLE incidents (
            rid INTEGER PRIMARY KEY AUTO_INCREMENT,
            dates DATE NOT NULL,
            origin INTEGER NOT NULL,
            airline INTEGER NOT NULL,
            aircraft INTEGER NOT NULL, 
            flightPhase VARCHAR(256) DEFAULT \"UNKNOWN\", 
            altitude INTEGER DEFAULT 0, 
            conditions INTEGER NOT NULL, 
            warning TINYINT NOT NULL,
            
            FOREIGN KEY (origin) REFERENCES airports(aid),
            FOREIGN KEY (airline) REFERENCES airlines(alid),
            FOREIGN KEY (aircraft) REFERENCES aircrafts(acid),
            FOREIGN KEY (conditions) REFERENCES conditions(cid),
            FOREIGN KEY (flightPhase) REFERENCES flightPhases(fpid)
          );
          "

dbExecute(dbcon, command)
```
### Creating trigger

This trigger is used upon insertion of new data into the incident table. Check value must be either 0 or 1. Check flightPhase makes sure that the entered phase is one of the harmonized option. If the given is not one of the 4 values, "UNKNOWN" is given. 
```{sql connection=dbcon}
DROP TRIGGER IF EXISTS newIncident
```

```{sql connection=dbcon}
CREATE TRIGGER newIncident
  BEFORE INSERT ON incidents
  FOR EACH ROW
  BEGIN
      /* check warning values */
      IF NEW.warning >= 1 THEN
        SET NEW.warning = 1;
      ELSEIF NEW.warning < 1 THEN
        SET NEW.warning = 0;
      END IF;
      
      /* check flightPhase values */
      if (EXISTS(SELECT * FROM flightPhases WHERE fpid = UPPER(NEW.flightPhase))) = 1 THEN
        SET NEW.flightPhase = UPPER(NEW.flightPhase);
      ELSE
        SET NEW.flightPhase = "UNKNOWN";
      END IF;
      
      
  END;


```


# Part 2: Loading data.

## Aircraft Model
In the dataset, it describes the vehicle that the pilot is operating as a type of aircraft and a model. Therefore, information regarding the vehical will be stored as some sort of aircraft id, the type of aircraft, and the model name. \n
### Models Dataframe
The dataframe is used to populate the MySQL dataframe and translate necessary information.




```{r}
# find the unique models of aircrafts
models <- unique(df$model)
# unique ids
aircraftID <- c(1:length(models))
# build model df before adjusting contents
model_df = data.frame(aircraft = df$aircraft, model = df$model) 
# remove duplicates
model_df <- model_df[!duplicated(model_df[ , c("model")]), ] 
# refer aircraft to aircraft id
model_df <- data.frame(acid = aircraftID, actid = aircraft_type_key_df$actid[match(model_df$aircraft, aircraft_type_key_df$original_aircraft_type)], model = model_df$model)


# check if empty model name exists
which(model_df$model == "")

# check if empty model name exists
which(toupper(model_df$model) == "UNKNOWN" | model_df$model == "NA" | model_df$model == "N/A" | is.null(model_df$model))

model_df

```

### Populate aircrafts table

```{r}

dbWriteTable(dbcon, 'aircrafts', model_df, append = TRUE, row.names = FALSE)
#dbReadTable(dbcon, "aircrafts")
```

## states

```{r}
state = toupper(unique(df$origin))

state = state[state != "N/A"]
state = c("UNKNOWN", state)
state_df = data.frame(state)
#state_df
```

```{r}

dbWriteTable(dbcon, 'states', state_df, append = TRUE, row.names = FALSE)
#dbReadTable(dbcon, "states")
```

## airports

```{r}
# find all unique values
airports_df = unique(df[, c("airport", "origin")])

# find all values of empty data
airports_df[airports_df == ""] <- "UNKNOWN"
airports_df[airports_df == "N/A"] <- "UNKNOWN"
airports_df[is.null(airports_df)] <- "UNKNOWN"


airports_df = data.frame(aid =  c(1:nrow(airports_df)), airportName = toupper(airports_df$airport), state = toupper(airports_df$origin))
airports_df["airportCode"] <- NA

# check for unique unknowns

#airports_df[which(airports_df$airport == "UNKNOWN"), ]

airports_df
```

```{r}
dbWriteTable(dbcon, 'airports', airports_df, append = TRUE, row.names = FALSE)
#dbReadTable(dbcon, "airports")
```

## airlines

Create the dataframe that holds all the unique airlines in the data set. "BUSINESS" is considered its own airline. "UNKNOWN" is already in the dataset
```{r}
# cleaning of special characters
df$airline = gsub("[^[:alnum:] ]", "", df$airline)

# change all "" into "UNKNOWN"
df$airline[which(df$airline == "")] = "UNKNOWN" 

airline = unique(df$airline)

airline = airline[which(airline != "")]
alid = c(1:(length(unique(airline))))
airlines_df = data.frame(alid, airline)

if (length(airlines_df$airline == "UNKNOWN") > 0) {
  print("UKNOWN exists")
}
airlines_df

```

```{r}

dbWriteTable(dbcon, 'airlines', airlines_df, append = TRUE, row.names = FALSE)
#dbReadTable(dbcon, "airlines")
```
## Conditions

### Creating the conditions_DF
```{r}
conditions = unique(df$sky_conditions)
cid = c(1:length(conditions))
print(cid)
print(conditions)
conditions_df <- data.frame(cid = cid, cond = toupper(conditions))
conditions_df["explanation"] <- NA

conditions_df
```


### Populate conditions table
```{r}

dbWriteTable(dbcon, 'conditions', conditions_df, append = TRUE, row.names = FALSE)
#dbReadTable(dbcon, "conditions")
```


### Populate flightPhases table

The dataframe was created in Question 1. The data is loaded here. 
```{r}

dbWriteTable(dbcon, 'flightPhases', flight_phase_df, append = TRUE, row.names = FALSE)
#dbReadTable(dbcon, "flightPhases")
```

## Incidents

### Creating incidents data frame
Prior to importing the data into the incidents table, the data must be cleaned and translated to reflect the unique foreign keys. 

```{r}

# remove columns not referenced in tables
delete_cols = c("wildlife_struck", "impact", "damage", "remains_collected_flag", "Remarks", "wildlife_size", "species", "heavy_flag")
df_truncated = df[,!(names(df)) %in% delete_cols]
df_truncated

# Create the origin vector with the correct foreign key ids
origin <- airports_df$aid[match(c(df_truncated$airport, df_truncated$origin), c(airports_df$airportName, airports_df$state))]
#origin
#origin_test = data.frame(df_truncated$airport, df_truncated$origin, origin)
#origin_test

# Create the aircraft vector with the correct foreign key ids
aircraft <- model_df$acid[match(df_truncated$model, model_df$model)]
#aircraft
#aircraft_test = data.frame(df.original = aircraft_type_key_df$actid[match(df_truncated$aircraft, aircraft_type_key_df$original_aircraft_type)], df_truncated$model, aircraft)
#aircraft_test

# Create the airline vector with the correct foreign key ids
airline <- airlines_df$alid[match(df_truncated$airline, airlines_df$airline)]
#airline_test = data.frame(df_truncated$airline, airline)
#airline_test

# Create the conditions vector with formatting
conditions <- conditions_df$cid[match(toupper(df_truncated$sky_conditions), conditions_df$cond)]


# Create the altitude vector; removed comma separation in string then converting to an integer
altitude <- as.integer(gsub(",", "", df_truncated$altitude_ft))
#altitude

# Create the flightphase vector with the harmonized values
flightphase <- flight_phase_dict[toupper(df_truncated$flight_phase)]

# Create the date vector to only hold month, day, and year of incidents
dates <- as.Date(df_truncated$flight_date, "%m/%d/%Y")

# Create the rid vector
rid <- df_truncated$rid

# created the warn vector by translating "Y" -> 1 and "N" -> 0 as boolean values. 1 and 0 are used because there's no native support for booleans in MySQL
warn <- as.integer(ifelse(toupper(df_truncated$pilot_warned_flag) == "Y", 1, 0))

# combine adjusted vectors into the final truncated version
df_truncated_final <- data.frame(rid, dates, origin, airline, aircraft, flightphase, altitude, conditions, warning = warn)
df_truncated_final
```

```{r}
dbWriteTable(dbcon, 'incidents', df_truncated_final, append = TRUE, row.names = FALSE)
# dbReadTable(dbcon, "incidents")
```

# Part 3: Showing tables after loading data

Below are the first 6 rows of the incidents table. The table is automatically organizing the data based on the primary key rid. 
The rid is kept kept an integer because all the rid entries are integers that do not start with 0. Each entry is a non-null value.
The occurence of when the impact with wildlife happened was recorded as a date-time type that was a string. This was coerced to a date type as described by the assigment. 
The origin and airline are using artificial foreign keys that link to a specific origin (i.e. an airport with a state) and an airline. These keys are used instead of the actual names because it is possible for airports and airlines to change names. By using artificial keys it is easy to make updates. Aircrafts are stored as artificial integer keys as well so that more models can easily be added and updated. It can hold more inforation regarding the models if future expansion is needed. This key also holds information regarding the type of aircraft such as helicopter or airplane. The flight phases are harmonized based on requirements. The altitude is stored as integers because the precision beyond ft. The default value is 0 because if there is an incident and an altitude is not recorded but a location is, then it is likely that it is stationary at an airport. Conditions are stored as 1 of 3 conditions. It allows room for expansion. Warning is stored as 1 for true and 0 for false because there is no native support for boolean values on MySQL. 
```{r}
head(dbReadTable(dbcon, "incidents"))
```

The aircrafts types are stored based to describe the type of aircraft the different models could signify. Currently there are two types but this allows for easy expansion and more description if needed in the future. 
```{r}
head(dbReadTable(dbcon, "aircraftTypes"))
```

The aircrafts are stored based on the type of aircraft and the model number. This data set has distinction between helicopter and airplanes. The aircraft id (acid) can be easily accessed by the incidents table. 
```{r}
head(dbReadTable(dbcon, "aircrafts"))
```

There are several conditions stored in the table. A cid is used to store the different types of condition and their names and explanations. The explanations are blank for expansion later. 
```{r}
head(dbReadTable(dbcon, "conditions"))
```

There are currently 4 harmonized definitions for flight phases. The aircraft can either be taking off, landing, or inflight when it happens. Otherwise it is unknown. 
```{r}
head(dbReadTable(dbcon, "flightPhases"))
```

The states table is stored in this table to have a complete list of states that are available when entering data regarding the location of the airport. This table also includes "UNKNOWN" because it is possible for inflight to be over seas where there are no states or for countries without a state system. 
```{r}
head(dbReadTable(dbcon, "states"))
```



The unique airport names and states which they reside. It allows for airportNames to be unknown but it must have a unique state associated with it. For instance, it is possible for an unknown airport but be within MA or another unknown airport within CT. This table lumps all unknown airports to one state. Each combination of unknown but have a unique state. The airportCode is kept empty for future expansion. The aid is used as the primary key to signify a unique name state combination. It is possible for two airports to share the same name but not the same state. All airports must have unique codes. 
```{r}
head(dbReadTable(dbcon, "airports"))
```

The airlines are stored with an airline id (alid) and an airline name associated with it. This table is to store specific names of airlines and link it to a unique name of the airline. If the airline name changes, when updating this table will suffice.
```{r}
head(dbReadTable(dbcon, "airlines"))
```

# Part 4

Create a SQL query against your database to find the 10 airlines with the greatest number of incidents.

```{sql connection=dbcon}
SELECT a.airline, COUNT(*) AS NumOfIncidents
  FROM incidents i
  JOIN airlines a ON i.airline = a.alid
  GROUP BY a.alid
  ORDER BY NumOfIncidents DESC
  LIMIT 10;
```



# Part 5
Create a SQL query against your database to find the flight phase that had an above average number bird strike incidents (during any flight phase). 


```{sql connection=dbcon}

WITH s AS (SELECT i.flightPhase, COUNT(*) incidents
  FROM incidents i 
  JOIN flightPhases f ON i.flightPhase = f.fpid
  GROUP BY i.flightPhase)
SELECT s.flightPhase as PhasesWithGreaterThanAVGIncidents
  FROM s
  WHERE s.incidents > (SELECT AVG(s.incidents) FROM s);

  
```
# Part 6

Create a SQL query against your database to find the number of bird strike incidents by month (across all years). Include all airlines and all flights. This query can help answer the question which month, historically, is the most dangerous for bird strikes.
```{sql connection=dbcon}
SELECT MONTHNAME(i.dates) month, Count(*) incidents
  FROM incidents i
  GROUP BY month;
  
  
```




# Part 7
Build a line chart that visualizes the number of bird strikes incidents per year from 2005 to 2011. Adorn the graph with appropriate axis labels, titles, legend, data labels, etc.


```{r}


command = "SELECT YEAR(i.dates) year, Count(*) incidents
          FROM incidents i
          GROUP BY year
          HAVING 2005 <= year AND year <= 2011
          ORDER BY year;"
summary = dbGetQuery(dbcon, command)
summary

# possible rounding function
roundUp <- function(x, nice=c(1,2,4,5,6,8,10)) {
    if(length(x) != 1) stop("'x' must be of length 1")
    10^floor(log10(x)) * nice[[which(x <= 10^floor(log10(x)) * nice)[[1]]]]
}

# title of graph
title = "FAA Birdstrikes Incidents"

# load x and y values
x = summary$year
y = summary$incidents

# expansion of x 
xlim = c((min(x) - 1),(max(x) + 1))


# create plot and points
plot(x, y, type = "l", lty = 1,  xlab="Year", ylab="Number of Incidents", xlim = xlim, cex = 0.9, main = title)
lines(x, y, type = "p", lty = 1)
text(x-0.1, y-20, pos = 2, labels = y, cex=0.9, offset =0.5)


# Add a legend to the plot
legend("topleft", legend=c("incidents"),
       col=c("black"), lty = 1:2, cex=0.8)
```


# Part 8
Create a stored procedure in MySQL (note that if you used SQLite, then you cannot complete this step) that adds a new incident to the database. You may decide what you need to pass to the stored procedure to add a bird strike incident and you must account for there being potentially a new airport. Note that if you used SQLite rather than the required MySQL for the practicum, then you cannot complete this question as SQLite does not support stored procedures.


From the query below, it can been seen that many of the foreign keys referring to the attributes are using artificial keys. Even columns that are referring to aritificial keys that have unique values such as LANDING for flightPhase require specific inputs. Therefore, all the attributes desides rid, dates, and warning require additional helper functions that would check and translate the inputted text regarding an incident into these keys. 

The goal is to call a stored procedure called newEntry with the folowing signature: `CALL newEntry("HELLICOPTER", "MY airport", "my bike", '10/27/22', 'my airline', 'my state', 'flying', 'NO cloud', "TRUE", 0)`

```{r}
command = "SELECT * FROM incidents;"

head(dbGetQuery(dbcon, command))
```

The stored function below translates TRUE and T text entries and returns a 1 for true and 0 for false. 
```{sql connection=dbcon}
DROP FUNCTION IF EXISTS translateWarning ;
```

```{sql connection=dbcon}
CREATE FUNCTION translateWarning(in_warning VARCHAR(20))
RETURNS INTEGER


BEGIN
  DECLARE out_warning INTEGER;
  
  If (UPPER(in_warning) = "TRUE" OR UPPER(in_warning) = "T") THEN
      SET out_warning = 1;
    ELSE
      SET out_warning = 0;
  END IF;
  RETURN (out_warning);
END;
```



The stored function below translates entries regarding the flight conditions. It ensures that only valid conditions are given. 
```{sql connection=dbcon}
DROP FUNCTION IF EXISTS translateCondition ;
```

```{sql connection=dbcon}
CREATE FUNCTION translateCondition(in_condition VARCHAR(20))
RETURNS INTEGER

BEGIN
  DECLARE out_condition INTEGER;
  
  IF (EXISTS (SELECT * FROM conditions WHERE conditions.cond = in_condition)) THEN
    SELECT conditions.cid into out_condition FROM conditions WHERE conditions.cond = in_condition;

  ELSE
    CALL test('Invalid condition given');
  END if;
  RETURN (out_condition);
END;
```

The stored function below translates the aircraft type and model into a unique integer identifier from the aircrafts table. 
```{sql connection=dbcon}
DROP FUNCTION IF EXISTS translateAircraft;
```

```{sql connection=dbcon}
CREATE FUNCTION translateAircraft(in_type VARCHAR(30),in_model VARCHAR(30))
RETURNS INTEGER

BEGIN
  DECLARE out_acid INTEGER;
  DECLARE out_type INTEGER;
  
  DECLARE aircraft_exists BOOLEAN;
  DECLARE type_exists BOOLEAN;
  
  SET in_type = UPPER(in_type);
  SET in_model = UPPER(in_model);
  
  /*Check if type exists*/
  SELECT (EXISTS (SELECT * FROM aircraftTypes WHERE aircraftType = in_type)) into type_exists;
  /*make sure the type exists*/
  IF NOT type_exists THEN
    INSERT INTO aircraftTypes(aircraftType) VALUES (in_type);
  END IF;
  SELECT actid INTO out_type FROM aircraftTypes WHERE aircraftType = in_type;
  /*Check if pair of aircraft type and model exists*/
  SELECT (EXISTS (SELECT * FROM aircrafts WHERE model = in_model AND actid = out_type)) into aircraft_exists;
  /*Make sure the specific pair exists*/
  IF NOT aircraft_exists THEN
    SELECT actid INTO out_type FROM aircraftTypes WHERE aircraftType = in_type;
    INSERT INTO aircrafts (actid, model) VALUES (out_type, in_model);
  END IF;
  
  SELECT acid INTO out_acid FROM aircrafts WHERE aircrafts.model = in_model AND aircrafts.actid = out_type;
  RETURN (out_acid);
END;
  
```

The function below ensures that a valid flightphase is given. If the given flightphase is not matching the one of the harmonized values, then "UNKNOWN" is returned. 
```{sql connection=dbcon}
DROP FUNCTION IF EXISTS translateFlightPhase;
```

```{sql connection=dbcon}
CREATE FUNCTION translateFlightPhase(in_flightPhase VARCHAR(30))
  RETURNS VARCHAR(30)
  
  BEGIN
    DECLARE out_flightPhase VARCHAR(30);
    SET in_flightPhase = UPPER(in_flightPhase);
    
    IF (EXISTS (SELECT * FROM flightPhases WHERE fpid = in_flightPhase)) THEN
      SET out_flightPhase = in_flightPhase;
    ELSE
      SET out_flightPhase = "UNKNOWN";
    END IF;
    RETURN (out_flightPhase);
  END;

    
```

The function below translate the given airline name to the respective airline id. If the airline does not exist, then the airline is added to the airline table. 
```{sql connection=dbcon}
DROP FUNCTION IF EXISTS translateAirline
```

```{sql connection=dbcon}
CREATE FUNCTION translateAirline(in_airline VARCHAR(30))
  RETURNS INTEGER
  
  BEGIN
    DECLARE out_alid INTEGER;
    SET in_airline = UPPER(in_airline);
    
    IF NOT (EXISTS (SELECT * FROM airlines WHERE airline = in_airline)) THEN
      INSERT INTO airlines(airline) VALUES (in_airline);
    END IF;
    SELECT alid INTO out_alid FROM airlines WHERE airline = in_airline;
    RETURN (out_alid);
  END;

    
```

The function below translates the airport name and the state that it resides in. The table currently allows for airports to share the same name as long as the state differs from each entry. For instance Logan International in MA and Logan International in CA are both valid as of right now. More information is needed regarding airport naming conventions world wide. This approach was chosen because there are several unnamed air fields in several different states and it might be useful to distinguish those. If an airport name or state name does not exist in the database, they will be added to their respective tables. 
```{sql connection=dbcon}
DROP FUNCTION IF EXISTS translateOrigin;
```

```{sql connection=dbcon}
CREATE FUNCTION translateOrigin(in_airport VARCHAR(30), in_state  VARCHAR(30))
  RETURNS INTEGER

BEGIN

  DECLARE out_aid INTEGER;
  
  DECLARE state_exists BOOLEAN;
  DECLARE airport_exists BOOLEAN;
  
  SET in_state = UPPER(in_state);
  SET in_airport = UPPER(in_airport);
  
  /*Check if the state exists*/
  SELECT (EXISTS (SELECT * FROM states WHERE state = in_state)) into state_exists;
  /*Check if the specific airport and state exists in airport table*/
  SELECT (EXISTS (SELECT * FROM airports WHERE airportName = in_airport AND state = in_state)) into airport_exists;
  
  /*Entry in airports table does not exist */
  IF NOT airport_exists THEN
    /*make sure the state exists*/
    IF NOT state_exists THEN
      INSERT INTO states (state) VALUES (in_state);
    END IF;
    INSERT INTO airports (airportName, state) VALUES (in_airport, in_state);
  END IF;
  
  SELECT aid INTO out_aid FROM airports WHERE airportName = in_airport AND state = in_state;
  RETURN (out_aid);
END;

    
```

The stored procedure below is the main procedure that automates adding new entries to the incident table. It utilizes all the translate functions within the database to input the correct foreign key references that are needed for each entry. When the correct data types are given, then the procedure returns the entry as a query. 
```{sql connection=dbcon}
DROP PROCEDURE IF EXISTS newEntry;
```

```{sql connection=dbcon}
CREATE PROCEDURE newEntry (
  IN in_aircraftType VARCHAR(50), 
  IN in_airportName VARCHAR(50),
  IN in_model VARCHAR(50), 
  IN in_date VARCHAR(50), 
  IN in_airlineName VARCHAR(50),
  IN in_state VARCHAR(50), 
  IN in_flightPhase VARCHAR(50), 
  IN in_condition VARCHAR(50), 
  IN in_warning VARCHAR(50), 
  IN in_altitude INTEGER)
  
BEGIN
  INSERT INTO incidents (dates, origin, airline, aircraft, flightPhase, altitude, conditions, warning) 
  VALUES (STR_TO_DATE(in_date, '%m/%d/%Y'), 
          translateOrigin(in_airportName, in_state),
          translateAirline(in_airlineName),
          translateAircraft(in_aircraftType, in_model), 
          translateFlightPhase(in_flightPhase), 
          in_altitude, 
          translateCondition(in_condition), 
          translateWarning(in_warning));
  SELECT * FROM incidents ORDER BY rid DESC LIMIT 1;

END;
```

Below is calling the procedure from the database in R. The strings must be given as single quotes surrounding double quotes to retain a string type when calling a function or procedure within the query. The results variable in r holds the entry that was just added into the database. 
```{r}
aircraft_type = '"HELLICOPTER"'
airport_name = '"MY airport"'
model_name = '"my cool model"'
date_today = '"10/27/22"'
airline_name = '"my airline"'
state_name = '"MASSACHUSETTS"'
flightPhase = '"INFLIGHT"'
flying_condition = '"NO CLOUD"'
warned = '"false"'
altitude = 10000

command = paste0("CALL newEntry(", paste(aircraft_type, airport_name, model_name, date_today, airline_name, state_name, flightPhase, flying_condition, warned, altitude, sep = ", "), ");")
command

res = dbSendQuery(dbcon, command)
data = fetch(res,n=-1)
while(dbMoreResults(dbcon) == TRUE) {
  dbNextResult(dbcon)
}
data
```
Shows "MY AIRPORT" was added to the airports table
```{r}
command = "SELECT * FROM airports WHERE aid = 1140;"

dbGetQuery(dbcon, command)
```
Shows "MY AIRLINE" was added to the airports table
```{r}
command = "SELECT * FROM airlines WHERE alid = 291;"

dbGetQuery(dbcon, command)
```
Shows "MY AIRLINE" was added to the airports table
```{r}
command = "SELECT * FROM aircrafts WHERE acid = 337;"

dbGetQuery(dbcon, command)
```

```{r}
dbDisconnect(dbcon)
```


